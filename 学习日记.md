### 2021-01-28

maven和idea默认打开debug编译模式，字节码中有方法参数名称的信息，所以spring mvc可以根据名称对参数进行绑定，而接口中对应的字节码没有的方法参数的名称，所以mybatis不能根据参数的名称进行处理参数绑定必须使用@param注解，https://fangshixiang.blog.csdn.net/article/details/99112603

### 2021-01-29

使用while包住wait()操作是为了防止虚假唤醒造成的程序错误 https://blog.nowcoder.net/n/5a168241b3da42029c4dff8eab6932e1

### 2021-02-01

1. Thread.currentThread().getContextClassLoader()获取线程当前的线程加载器，解决SPI中接口使用bootstrap加载器加载，但是具体的实现类bootstrap加载不到的问题，如果不指定当前线程的上下文加载器的时候，线程将继承其父线程的上下文类加载器，Java 应用运行的初始线程的上下文类加载器是系统类加载器

2. Kafka中的消息清除是通过指定主题的保留时间或为其定义磁盘配额自动完成的，kafka中数据的删除跟有没有消费者消费完全无关。数据的删除，只跟kafka broker上面上面的这两个配置有关：

   ```yaml
   log.retention.hours=48 #数据最多保存48小时
   log.retention.bytes=1073741824 #数据最多1G
   ```

### 2021-02-03

1. 泛型

  - `Class`（原始/基本类型，也叫`raw type`）：不仅仅包含我们平常所指的类、枚举、数组、注解，还包括基本类型int、float等等

  - `TypeVariable`（类型变量）：比如`List<T>`中的T等

  - `WildcardType`（ 泛型表达式类型）：例如`List< ? extends Number> `中的 ? extends Number

  - `ParameterizedType`（参数化类型）：就是我们平常所用到的带泛型参数的集合或者对象，如List、Map（注意和`TypeVariable`的区别）

  - `GenericArrayType`（数组类型）：*并不是我们工作中所使用的*数组String[] 、byte[]（这种都属于Class），而是带有泛型的数组，即T[] 或这List<String> []

    > 实例代码参考 https://github.com/531621028/java-demo/blob/master/src/main/java/GenericTypeTest.java

   从上面的程序输出来看，泛型变量大概就两种，一种是`ParameterizedType`和`GenericArrayType`，像`TypeVariable`和`WildcardType`都是里面返回变量里面对应的类型，就像wildcardTypeSet的实际类型是WildcardType一样.

   `List<? entends T>[]`：这里的List就是ParameterizedType，T就是TypeVariable，?  extends T就是WildcardType（注意，WildcardType不是Java类型，而是一个表达式），整个List< ? entends T>[]就是GenericArrayType

2. 四种引用类型
	- 强引用: 只要强引用还存在，垃圾收集器**永远不会**回收（JVM宁愿抛出OOM异常也不回收强引用所指向的对）被引用的对象。但是，强引用可能会造成**内存泄露**哦~, 我们平常使用的最多的的就是这种
	
	- 软引用：软引用（Soft Reference)：是用来描述一些还有用**但并非必须**的对象。对于软引用对象，**如果内存`充足`(注意此处对充足二字的理解)gc不会管它，如果内存不够了，它就不能幸免了**。
	
	- 弱引用：弱引用（WeakReference）：**弱引用和软引用很像**，当gc时，无论内存是否充足，**都会回收被弱引用关联的对象** 它也可以和`ReferenceQueue`配合使用：如果弱引用所引用的对象被JVM回收，这个弱引用就会被加入到与之关联的引用队列中（使用方式同上示例）
	
	- 虚引用（PhantomReference）：**虚引用和前面的软引用、弱引用不同**，它并不影响对象的`生命周期`。一个对象与虚引用关联，则**跟没有引用与之关联一样**，所以get()方法`永远`返回null，在**任何时候**都可能被垃圾回收器回收。因此它**必须**和`ReferenceQueue`一起使用，**否则没有任何意义**。**它的作用一般在于跟踪垃圾回收过程（netty源码中有对此种引用的使用，非常巧妙，有兴趣可自己研究一下**
	
	  ReferenceQueue：`软引用可用来实现内存敏感的高速缓存`。软引用可以和一个引用队列（`ReferenceQueue`）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个`软引用本身`加入到与之关联的引用队列中，方便你手动释放内存。引用对象指向的对象 GC 会自动清理，**但是引用对象本身也是对象（是对象就占用一定资源），所以需要我们自己手动清理哦~**在实际生产环境中，我们可能会用个子线程专门去处理这个回收问题。

### 2021-02-04

1. 创建对象的五种方法

   - 1. new关键字

     > 最常用的

   - 2. Class.newInstance

     > 必须要有无参的public构造器

   - 3. Constructor.newInstance

     > 我们可以通过这个`newInstance`方法调用有参数（不再必须是无参）的和私有的构造函数（不再必须是public）

   - 4. Clone方法反序列化

     > 无论何时我们调用一个对象的`clone`方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用`clone`方法创建对象`并不会调用任何构造函数`。要使用clone方法，我们**必须先实现Cloneable接口**并复写Object的clone方法（因为Object的这个方法是protected的，你若不复写，外部也调用不了呀）,不实现Cloneable调用clone方法会抛`CloneNotSupportedException`异常

   - 5. 反序列化
   
     > 当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并**不会调用任何构造函数**。为了反序列化一个对象，我们需要让我们的类实现`Serializable`接口,JDK序列化、反序列化特别特别耗内存

2. Java中定时任务的实现方式

   - 1. Timer和TimerTask

        > 一个Timer定时器，是单线程的，一个Timer可以调度任意多个TimerTask，所有任务都存储在一个队列中顺序执行，如果需要多个TimerTask并发执行，则需要创建两个多个Timer

   - 2. ScheduledThreadPoolExecutor

        > 实例代码参考https://github.com/531621028/java-demo/blob/master/src/main/java/ScheduledThreadPoolExecutorTest.java

        - public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit); // 没有返回值
        - public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit); // 有返回值
        - public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit); // 固定的延迟执行，待上一次任务执行完成之后等待delay的时间执行
        - public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,long initialDelay, long period, TimeUnit unit); // 固定的频率执行，会等待上一次任务执行完成，如果等待时间超过了period的时间会立即执行下一次任务
   ### 2021-02-05

   在Update语句中不要使用子查询，因为Update是更新语句，子查询中所涉及到的条件字段会被加锁，这时候如何有其他的线程要更新子查询表中的数据，会被当前的线程阻塞主，在并发高的的时候可能会造成死锁

   ### 2021-02-07

   1. 函数式接口
      - **Supplier**， 供应者，表达的不是从一个参数空间到结果空间的映射能力，而是表达一种生成能力。
      - **Consumer**，没有返回值的消费者
      - **Predicate**， 断言接口
      - **Function**，其默认实现了3个default方法，分别是compose、andThen和identity，compose 和 andThen 的不同之处是函数执行的顺序不同。andThen就是按照正常思维：先执行调用者，再执行入参的。然后compose 是反着来的，这点需要注意。

### 2021-02-19

1. `Thread.join()` : Waits for this thread to die.等待当前线程执行完成
2. += 隐式的将加操作的结果类型强制转换为持有结果的类型

### 2021-02-21

1. 当一个阻塞方法检测到中断并抛出 `InterruptedException` 时，它清除中断状态。如果捕捉到 `InterruptedException` 但是不能重新抛出它，那么应该保留中断发生的证据，以便调用栈中更高层的代码能知道中断，并对中断作出响应
2. 泛型只是在定义的说明支持多种类型，但是泛型类和接口在实例化的时候必须指定泛型的具体类型，调用泛型方法时，可以指定泛型，也可以不指定泛型
   - 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object
   - 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类
3. 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限 , 摘自《Effective Java》 https://www.pdai.tech/md/java/basic/java-basic-x-generic.html
   - 如果参数化类型表示一个 T 的生产者，使用 < ? extends T>; 
   - 如果它表示一个 T 的消费者，就使用 < ? super T>； 
   - 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。

4. **finally** – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。finall语句始终是在try和catch语句后面执行，如果finally中使用了return或者throw等终止方法的语句，则会覆盖try和catch中的返回值和异常，因为在try和catch中的throw和return语句只是在堆栈上存一个临时值，会被finally中的值给覆盖；所以在finally不要使用throw和return语句。测试代码如下https://github.com/531621028/java-demo/blob/master/src/main/java/ExceptionTest.java

### 2020-02-23

1. PriorityQueue，初始化的时候如果不传入Comparator,那么里面存储的对象必须实现Comparable接口，不然会有报错

### 2020-02-25

1. Kafka中的零拷贝**基于 sendfile 实现的 FileChannel**:传统的文件网络传输需要经过4次复制，文件->内核readBuffer->用户模式->内核模式ScoketBuffer->网卡;经过4次上下文的切换，使用零拷贝技术之后文件传输只需要 文件-> 内核readBuffer->内核模式的SocketBuffer(只有数据地址和长度信息) -> 网卡；这里2 次上下文切换、0 次 CPU 拷贝以及 2 次 DMA 拷贝。 参考 https://www.cnblogs.com/rickiyang/p/13265043.html中的sendfile + DMA gather copy

### 2020-02-28

1. Mybatis中，MetaClass 中的 findProperty() 方法是实现属性查找的核心方法，他根据输入的字符串以"."为分隔符找到从当前类到属性的以"."拼接的路径，这个查找过程中是不区分大小写的，而返回的是区分大小写的路径，用来处理字符串到属性真实路径的映射。代码参考 https://github.com/531621028/spring-cloud-demo/blob/master/boot-test/src/main/java/com/hkk/boottest/mybatis/MeatClassTest.java

